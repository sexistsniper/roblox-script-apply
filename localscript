-- LocalScript in StarterPlayerScripts
-- bigger build system w/ corner snap + more random stuff bolted on
-- still needs Block, WallBlock, FloorBlock in ReplicatedStorage
-- all anchored + collide true

local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local DataStoreService = game:GetService("DataStoreService")

local player = Players.LocalPlayer
local mouse = player:GetMouse()

-- remote stubs (pretend multiplayer sync)
local remotesFolder = ReplicatedStorage:FindFirstChild("BuildRemotes") or Instance.new("Folder", ReplicatedStorage)
remotesFolder.Name = "BuildRemotes"
local placeRemote = Instance.new("RemoteEvent", remotesFolder); placeRemote.Name = "Place"
local deleteRemote = Instance.new("RemoteEvent", remotesFolder); deleteRemote.Name = "Delete"

-- datastore fake (real one on server but we mock here)
local buildStore = DataStoreService:GetDataStore("PlayerBuilds")

-- templates
local blockTemplates = {
	ReplicatedStorage:WaitForChild("Block"),
	ReplicatedStorage:WaitForChild("WallBlock"),
	ReplicatedStorage:WaitForChild("FloorBlock")
}
local currentTemplateIndex = 1
local blockTemplate = blockTemplates[currentTemplateIndex]

-- grid + snap vars
local GRID_SIZE = 4
local snapEnabled = true

-- placement vars
local currentRotation = 0
local ghostPart
local placedBlocks = {} -- holds info tables
local placedLookup = {} -- id -> part

-- undo/redo stacks
local undoStack = {}
local redoStack = {}

-- helper unique id for blocks
local function newId()
	return HttpService:GenerateGUID(false)
end

-- snap to grid
local function snapBase(position)
	if not snapEnabled then return position end
	return Vector3.new(
		math.floor(position.X / GRID_SIZE + 0.5) * GRID_SIZE,
		math.floor(position.Y / GRID_SIZE + 0.5) * GRID_SIZE,
		math.floor(position.Z / GRID_SIZE + 0.5) * GRID_SIZE
	)
end

-- corner offset thing
local function getCornerOffset(size, rotation)
	local half = size / 2
	rotation = rotation % 360
	if rotation == 0 then
		return Vector3.new(half.X, half.Y, half.Z)
	elseif rotation == 90 then
		return Vector3.new(-half.Z, half.Y, half.X)
	elseif rotation == 180 then
		return Vector3.new(-half.X, half.Y, -half.Z)
	elseif rotation == 270 then
		return Vector3.new(half.Z, half.Y, -half.X)
	end
	return Vector3.new(0, half.Y, 0)
end

-- ghost stuff
local function makeGhost()
	if ghostPart then ghostPart:Destroy() end
	ghostPart = blockTemplate:Clone()
	ghostPart.Transparency = 0.5
	ghostPart.CanCollide = false
	ghostPart.Anchored = true
	ghostPart.Name = "GhostPart"
	ghostPart.Parent = workspace
end

local function updateGhost()
	if ghostPart and mouse.Hit then
		local basePos = snapBase(mouse.Hit.Position)
		local offset = getCornerOffset(blockTemplate.Size, currentRotation)
		local finalPos = basePos + offset
		ghostPart.CFrame = CFrame.new(finalPos) * CFrame.Angles(0, math.rad(currentRotation), 0)
	end
end

-- overlap check
local function canPlaceAt(cframe)
	local newSize = blockTemplate.Size
	local newPos = cframe.Position
	local newName = blockTemplate.Name
	local tolerance = 0.05

	for _, part in ipairs(workspace:GetChildren()) do
		if part:IsA("BasePart") and part:GetAttribute("PlacedBlock") then
			local size = part.Size
			local pos = part.Position
			local partName = part.Name

			if newName == "WallBlock" and partName ~= "WallBlock" then
				continue
			end
			if partName == "WallBlock" and newName ~= "WallBlock" then
				continue
			end

			local overlapX = math.abs(newPos.X - pos.X) < (newSize.X/2 + size.X/2 - tolerance)
			local overlapY = math.abs(newPos.Y - pos.Y) < (newSize.Y/2 + size.Y/2 - tolerance)
			local overlapZ = math.abs(newPos.Z - pos.Z) < (newSize.Z/2 + size.Z/2 - tolerance)

			if overlapX and overlapY and overlapZ then
				return false
			end
		end
	end
	return true
end

-- actual placement
local function placeBlock()
	if ghostPart then
		local cframe = ghostPart.CFrame
		if canPlaceAt(cframe) then
			local newBlock = blockTemplate:Clone()
			newBlock.CFrame = cframe
			newBlock.Anchored = true
			newBlock.Parent = workspace
			newBlock:SetAttribute("PlacedBlock", true)
			local id = newId()
			newBlock:SetAttribute("BlockId", id)

			local info = {
				id = id,
				name = blockTemplate.Name,
				pos = {cframe.Position.X, cframe.Position.Y, cframe.Position.Z},
				rot = currentRotation
			}
			placedBlocks[#placedBlocks+1] = info
			placedLookup[id] = newBlock

			undoStack[#undoStack+1] = {action="place", data=info}
			redoStack = {}

			placeRemote:FireServer(info)
		else
			warn("cant place, overlap")
		end
	end
end

-- delete nearest block to mouse
local function deleteBlock()
	local target = mouse.Target
	if target and target:GetAttribute("PlacedBlock") then
		local id = target:GetAttribute("BlockId")
		local info
		for i, block in ipairs(placedBlocks) do
			if block.id == id then
				info = block
				table.remove(placedBlocks, i)
				break
			end
		end
		if id then
			undoStack[#undoStack+1] = {action="delete", data=info}
			redoStack = {}
			placedLookup[id] = nil
			deleteRemote:FireServer(id)
		end
		target:Destroy()
	end
end

-- undo + redo
local function undo()
	local last = table.remove(undoStack)
	if not last then return end
	if last.action == "place" then
		local id = last.data.id
		if placedLookup[id] then
			placedLookup[id]:Destroy()
			placedLookup[id] = nil
		end
		for i, v in ipairs(placedBlocks) do
			if v.id == id then table.remove(placedBlocks, i) break end
		end
	elseif last.action == "delete" then
		local info = last.data
		local template = ReplicatedStorage:FindFirstChild(info.name)
		if template then
			local newBlock = template:Clone()
			newBlock.CFrame = CFrame.new(Vector3.new(info.pos[1], info.pos[2], info.pos[3]))
				* CFrame.Angles(0, math.rad(info.rot), 0)
			newBlock.Anchored = true
			newBlock.Parent = workspace
			newBlock:SetAttribute("PlacedBlock", true)
			newBlock:SetAttribute("BlockId", info.id)
			placedBlocks[#placedBlocks+1] = info
			placedLookup[info.id] = newBlock
		end
	end
	redoStack[#redoStack+1] = last
end

local function redo()
	local last = table.remove(redoStack)
	if not last then return end
	if last.action == "place" then
		-- re-place
		local info = last.data
		local template = ReplicatedStorage:FindFirstChild(info.name)
		if template then
			local newBlock = template:Clone()
			newBlock.CFrame = CFrame.new(Vector3.new(info.pos[1], info.pos[2], info.pos[3]))
				* CFrame.Angles(0, math.rad(info.rot), 0)
			newBlock.Anchored = true
			newBlock.Parent = workspace
			newBlock:SetAttribute("PlacedBlock", true)
			newBlock:SetAttribute("BlockId", info.id)
			placedBlocks[#placedBlocks+1] = info
			placedLookup[info.id] = newBlock
		end
	elseif last.action == "delete" then
		local id = last.data.id
		if placedLookup[id] then
			placedLookup[id]:Destroy()
			placedLookup[id] = nil
		end
		for i, v in ipairs(placedBlocks) do
			if v.id == id then table.remove(placedBlocks, i) break end
		end
	end
	undoStack[#undoStack+1] = last
end

-- cycle blocks
local function cycleBlock(next)
	if next then
		currentTemplateIndex += 1
		if currentTemplateIndex > #blockTemplates then
			currentTemplateIndex = 1
		end
	else
		currentTemplateIndex -= 1
		if currentTemplateIndex < 1 then
			currentTemplateIndex = #blockTemplates
		end
	end
	blockTemplate = blockTemplates[currentTemplateIndex]
	makeGhost()
	updateGhost()
end

-- save build (local print + datastore fake)
local function saveBuild()
	local data = HttpService:JSONEncode(placedBlocks)
	print("saving:", data)
end

local function loadBuild(dataString)
	local ok, data = pcall(function()
		return HttpService:JSONDecode(dataString)
	end)
	if ok then
		for _, part in ipairs(workspace:GetChildren()) do
			if part:GetAttribute("PlacedBlock") then part:Destroy() end
		end
		placedBlocks = {}
		placedLookup = {}
		for _, info in ipairs(data) do
			local template = ReplicatedStorage:FindFirstChild(info.name)
			if template then
				local newBlock = template:Clone()
				newBlock.CFrame = CFrame.new(Vector3.new(info.pos[1], info.pos[2], info.pos[3]))
					* CFrame.Angles(0, math.rad(info.rot), 0)
				newBlock.Anchored = true
				newBlock.Parent = workspace
				newBlock:SetAttribute("PlacedBlock", true)
				newBlock:SetAttribute("BlockId", info.id or newId())
				placedBlocks[#placedBlocks+1] = info
				placedLookup[info.id] = newBlock
			end
		end
	else
		warn("load fail")
	end
end

-- quick UI just text
local gui = Instance.new("ScreenGui", player.PlayerGui)
local label = Instance.new("TextLabel", gui)
label.Size = UDim2.new(0,200,0,50)
label.Position = UDim2.new(0,10,0,10)
label.BackgroundTransparency = 0.5
label.TextScaled = true
label.Text = "block system"

local function updateLabel()
	label.Text = blockTemplate.Name.." rot:"..currentRotation.." grid:"..GRID_SIZE
end

-- ghost at start
makeGhost()

-- events
mouse.Move:Connect(function()
	updateGhost()
	updateLabel()
end)
mouse.Button1Down:Connect(placeBlock)
mouse.Button2Down:Connect(deleteBlock)

UserInputService.InputBegan:Connect(function(input,gpe)
	if gpe then return end
	if input.KeyCode == Enum.KeyCode.Q then
		currentRotation = (currentRotation - 90) % 360
		updateGhost()
	elseif input.KeyCode == Enum.KeyCode.E then
		currentRotation = (currentRotation + 90) % 360
		updateGhost()
	elseif input.KeyCode == Enum.KeyCode.One then
		cycleBlock(true)
	elseif input.KeyCode == Enum.KeyCode.Two then
		cycleBlock(false)
	elseif input.KeyCode == Enum.KeyCode.F5 then
		saveBuild()
	elseif input.KeyCode == Enum.KeyCode.F6 then
		local fake = HttpService:JSONEncode(placedBlocks)
		loadBuild(fake)
	elseif input.KeyCode == Enum.KeyCode.Delete then
		deleteBlock()
	elseif input.KeyCode == Enum.KeyCode.Z then
		undo()
	elseif input.KeyCode == Enum.KeyCode.Y then
		redo()
	elseif input.KeyCode == Enum.KeyCode.G then
		snapEnabled = not snapEnabled
	elseif input.KeyCode == Enum.KeyCode.Plus or input.KeyCode == Enum.KeyCode.KeypadPlus then
		GRID_SIZE += 1
	elseif input.KeyCode == Enum.KeyCode.Minus or input.KeyCode == Enum.KeyCode.KeypadMinus then
		GRID_SIZE = math.max(1, GRID_SIZE-1)
	end
	updateLabel()
end)

RunService.RenderStepped:Connect(updateGhost)
