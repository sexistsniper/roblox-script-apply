--// Multiplayer Build System (Client)
--// Full version with line-by-line comments for review
--// Handles ghost preview, snapping, rotation, cycling, undo/redo, UI, and server requests

--== Services ==--
local Players = game:GetService("Players") -- get Roblox Players service
local UserInputService = game:GetService("UserInputService") -- input events (keyboard/mouse)
local ContextActionService = game:GetService("ContextActionService") -- lets us bind custom actions
local ReplicatedStorage = game:GetService("ReplicatedStorage") -- shared storage for templates + remotes
local RunService = game:GetService("RunService") -- used for frame updates (RenderStepped)
local HttpService = game:GetService("HttpService") -- to generate GUIDs for undo/redo

--== Player references ==--
local LocalPlayer = Players.LocalPlayer -- reference to the player running this LocalScript
local Camera = workspace.CurrentCamera -- camera object for raycasting from screen to 3D

--== Build settings ==--
local GRID_SIZE = 4 -- default snapping size in studs
local SNAP_ENABLED = true -- toggle for snapping on/off
local ROTATION_STEP_DEG = 90 -- rotation increment in degrees
local TEMPLATE_NAMES = { "Block", "WallBlock", "FloorBlock" } -- names of parts stored in ReplicatedStorage

--== State variables ==--
local currentTemplateIndex = 1 -- index of which block type is active
local currentRotationDeg = 0 -- current rotation applied to ghost/placement
local ghostPart = nil -- ghost preview part reference
local undoStack = {} -- table storing undo actions
local redoStack = {} -- table storing redo actions

--== Remote references ==--
local RemotesFolder = ReplicatedStorage:WaitForChild("BuildRemotes") -- folder created on server
local REQ_Place = RemotesFolder:WaitForChild("PlaceRequest") -- remote event for requesting placement
local REQ_Delete = RemotesFolder:WaitForChild("DeleteRequest") -- remote event for requesting deletion
local EVT_Error = RemotesFolder:WaitForChild("ClientError") -- remote event for server → client error messages

--== UI setup ==--
local gui = Instance.new("ScreenGui") -- new screen GUI object
gui.IgnoreGuiInset = true -- ignore Roblox topbar inset
gui.ResetOnSpawn = false -- persists when respawning
gui.Parent = LocalPlayer:WaitForChild("PlayerGui") -- parent GUI to player

local label = Instance.new("TextLabel") -- new text label for status
label.Size = UDim2.new(0, 420, 0, 28) -- set size in pixels
label.Position = UDim2.new(0, 10, 0, 10) -- place top-left corner
label.BackgroundTransparency = 0.35 -- semi-transparent background
label.TextScaled = true -- text auto scales to fill label
label.Text = "Build System Ready" -- initial text
label.Parent = gui -- parent to GUI

--== Utility Functions ==--

-- snapBase: snaps a Vector3 position to the nearest GRID_SIZE if snapping is enabled
local function snapBase(v3: Vector3): Vector3
	if not SNAP_ENABLED then return v3 end -- if snapping off, return raw position
	return Vector3.new( -- snap each axis individually
		math.floor(v3.X / GRID_SIZE + 0.5) * GRID_SIZE,
		math.floor(v3.Y / GRID_SIZE + 0.5) * GRID_SIZE,
		math.floor(v3.Z / GRID_SIZE + 0.5) * GRID_SIZE
	)
end

-- currentTemplate: gets currently active template part from ReplicatedStorage
local function currentTemplate(): BasePart
	return ReplicatedStorage:WaitForChild(TEMPLATE_NAMES[currentTemplateIndex]) -- safe wait for part
end

-- updateLabel: refreshes the GUI label with current settings
local function updateLabel()
	label.Text = string.format( -- format string with state
		"Part: %s | Rot: %d° | Grid: %d | Snap: %s",
		TEMPLATE_NAMES[currentTemplateIndex], -- block type
		currentRotationDeg, -- rotation angle
		GRID_SIZE, -- grid size
		SNAP_ENABLED and "ON" or "OFF" -- snap toggle
	)
end

-- ensureGhost: destroys old ghost and spawns a new one for the selected template
local function ensureGhost()
	if ghostPart then ghostPart:Destroy() end -- remove old ghost if exists
	ghostPart = currentTemplate():Clone() -- clone new ghost
	ghostPart.Name = "GhostPart" -- name it clearly
	ghostPart.Transparency = 0.5 -- make semi-transparent
	ghostPart.CanCollide = false -- disable collisions
	ghostPart.Anchored = true -- anchored so it doesn’t fall
	ghostPart.Parent = workspace -- put into world
end

-- getMouseWorldCFrame: raycasts from screen mouse pos into 3D world, returns CFrame at hit
local function getMouseWorldCFrame(): CFrame?
	local mousePos = UserInputService:GetMouseLocation() -- get mouse pixel pos
	local ray = Camera:ViewportPointToRay(mousePos.X, mousePos.Y) -- convert to 3D ray
	local rayParams = RaycastParams.new() -- raycast params
	rayParams.FilterType = Enum.RaycastFilterType.Exclude -- blacklist filter type
	rayParams.FilterDescendantsInstances = { LocalPlayer.Character, ghostPart } -- ignore self + ghost
	local result = workspace:Raycast(ray.Origin, ray.Direction * 1000, rayParams) -- shoot ray
	if not result then return nil end -- nothing hit
	return CFrame.new(result.Position) -- return hit position as CFrame
end

-- updateGhost: moves ghost to snapped mouse hit location with current rotation
local function updateGhost()
	if not ghostPart then return end -- ensure ghost exists
	local hitCFrame = getMouseWorldCFrame() -- raycast mouse
	if not hitCFrame then return end -- stop if nothing hit
	local basePos = snapBase(hitCFrame.Position) -- snap to grid
	ghostPart.CFrame = CFrame.new(basePos) * CFrame.Angles(0, math.rad(currentRotationDeg), 0) -- apply rotation
end

--== Placement + Deletion ==--

-- newLocalId: generates a GUID for local tracking (undo/redo)
local function newLocalId()
	return HttpService:GenerateGUID(false) -- create GUID string
end

-- requestPlace: asks server to place block at ghost location
local function requestPlace()
	if not ghostPart then return end -- no ghost means no placement
	local id = newLocalId() -- generate client id
	local payload = { -- build payload table
		templateName = TEMPLATE_NAMES[currentTemplateIndex], -- type of block
		worldCFrame = ghostPart.CFrame, -- target position/rotation
		rotationDeg = currentRotationDeg, -- rotation angle
		gridSize = GRID_SIZE, -- grid size used
		snap = SNAP_ENABLED, -- snap toggle
		clientId = id, -- store client id for undo tracking
	}
	REQ_Place:FireServer(payload) -- send to server
	undoStack[#undoStack + 1] = { action = "place", id = id } -- push to undo stack
	redoStack = {} -- clear redo stack
end

-- requestDelete: raycasts to target block and asks server to delete
local function requestDelete()
	local mousePos = UserInputService:GetMouseLocation() -- mouse pixel pos
	local ray = Camera:ViewportPointToRay(mousePos.X, mousePos.Y) -- convert to ray
	local params = RaycastParams.new() -- ray params
	params.FilterType = Enum.RaycastFilterType.Exclude-- exclude list
	params.FilterDescendantsInstances = { LocalPlayer.Character, ghostPart } -- ignore self/ghost
	local hit = workspace:Raycast(ray.Origin, ray.Direction * 1000, params) -- shoot ray
	if not hit then return end -- nothing hit
	local target = hit.Instance -- get instance hit
	if not target or not target:IsA("BasePart") then return end -- only baseparts
	local id = target:GetAttribute("BlockId") -- get block id
	if id then -- ensure valid id
		REQ_Delete:FireServer(id) -- tell server to delete
		undoStack[#undoStack + 1] = { action = "delete", id = id } -- push to undo
		redoStack = {} -- clear redo
	end
end

--== Undo / Redo ==--

-- undo: reverts last local action
local function undo()
	local last = table.remove(undoStack) -- pop last action
	if not last then return end -- no action
	if last.action == "place" then -- if it was placement
		REQ_Delete:FireServer(last.id) -- request server delete
	elseif last.action == "delete" then
		-- re-place not supported without full server memory
	end
	redoStack[#redoStack + 1] = last -- push to redo
end

-- redo: reapplies last undone action
local function redo()
	local last = table.remove(redoStack) -- pop from redo
	if not last then return end -- nothing to redo
	if last.action == "place" then
		-- re-place skipped
	elseif last.action == "delete" then
		REQ_Delete:FireServer(last.id) -- redo delete
	end
	undoStack[#undoStack + 1] = last -- push back to undo
end

--== Input Handlers ==--

-- rotateLeft: rotate -90
local function rotateLeft(_, state)
	if state ~= Enum.UserInputState.Begin then return end
	currentRotationDeg = (currentRotationDeg - ROTATION_STEP_DEG) % 360
	updateGhost(); updateLabel()
end

-- rotateRight: rotate +90
local function rotateRight(_, state)
	if state ~= Enum.UserInputState.Begin then return end
	currentRotationDeg = (currentRotationDeg + ROTATION_STEP_DEG) % 360
	updateGhost(); updateLabel()
end

-- cycleNext: go to next block template
local function cycleNext(_, state)
	if state ~= Enum.UserInputState.Begin then return end
	currentTemplateIndex += 1
	if currentTemplateIndex > #TEMPLATE_NAMES then currentTemplateIndex = 1 end
	ensureGhost(); updateGhost(); updateLabel()
end

-- cyclePrev: go to previous block template
local function cyclePrev(_, state)
	if state ~= Enum.UserInputState.Begin then return end
	currentTemplateIndex -= 1
	if currentTemplateIndex < 1 then currentTemplateIndex = #TEMPLATE_NAMES end
	ensureGhost(); updateGhost(); updateLabel()
end

-- toggleSnap: toggle snapping on/off
local function toggleSnap(_, state)
	if state ~= Enum.UserInputState.Begin then return end
	SNAP_ENABLED = not SNAP_ENABLED
	updateGhost(); updateLabel()
end

-- gridPlus: increase grid size
local function gridPlus(_, state)
	if state ~= Enum.UserInputState.Begin then return end
	GRID_SIZE = math.clamp(GRID_SIZE + 1, 1, 64)
	updateGhost(); updateLabel()
end

-- gridMinus: decrease grid size
local function gridMinus(_, state)
	if state ~= Enum.UserInputState.Begin then return end
	GRID_SIZE = math.clamp(GRID_SIZE - 1, 1, 64)
	updateGhost(); updateLabel()
end

-- primaryPlace: left mouse button places block
local function primaryPlace(_, state)
	if state ~= Enum.UserInputState.Begin then return end
	requestPlace()
end

-- deleteKey: pressing R deletes block under mouse
local function deleteKey(_, state)
	if state ~= Enum.UserInputState.Begin then return end
	requestDelete()
end

-- doUndo: bound to Z for undo
local function doUndo(_, state)
	if state ~= Enum.UserInputState.Begin then return end
	undo()
end

-- doRedo: bound to Y for redo
local function doRedo(_, state)
	if state ~= Enum.UserInputState.Begin then return end
	redo()
end

--== Initialization ==--

ensureGhost() -- create ghost initially
updateLabel() -- update label text
RunService.RenderStepped:Connect(updateGhost) -- update ghost every frame

-- bind all inputs with ContextActionService
ContextActionService:BindAction("BuildPlace", primaryPlace, true, Enum.UserInputType.MouseButton1) -- left click place
ContextActionService:BindAction("BuildDeleteKey", deleteKey, true, Enum.KeyCode.R) -- R to delete (freeing right click for camera)
ContextActionService:BindAction("BuildRotL", rotateLeft, true, Enum.KeyCode.Q) -- Q rotate left
ContextActionService:BindAction("BuildRotR", rotateRight, true, Enum.KeyCode.E) -- E rotate right
ContextActionService:BindAction("BuildNext", cycleNext, true, Enum.KeyCode.One) -- 1 next block
ContextActionService:BindAction("BuildPrev", cyclePrev, true, Enum.KeyCode.Two) -- 2 prev block
ContextActionService:BindAction("BuildSnap", toggleSnap, true, Enum.KeyCode.G) -- G toggle snap
ContextActionService:BindAction("BuildGridPlus", gridPlus, true, Enum.KeyCode.Equals, Enum.KeyCode.KeypadPlus) -- + grid up
ContextActionService:BindAction("BuildGridMinus", gridMinus, true, Enum.KeyCode.Minus, Enum.KeyCode.KeypadMinus) -- - grid down
ContextActionService:BindAction("BuildUndo", doUndo, true, Enum.KeyCode.Z) -- Z undo
ContextActionService:BindAction("BuildRedo", doRedo, true, Enum.KeyCode.Y) -- Y redo

-- handle server error events
EVT_Error.OnClientEvent:Connect(function(message: string)
	warn("[BuildSystem Error]:", message) -- log warning
end)
